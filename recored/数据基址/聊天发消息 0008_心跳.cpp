//心跳包 每分钟一次

===============================================================================================================================================================================================

===============================================================================================================================================================================================
 

Address  To       From     Siz Comment                Party 
0018EEEC 300920DF 757234B5 20  ws2_32.757234B5        User  //sendto
0018EF0C 30092053 300920DF 58  common.300920DF        User
0018EF64 30098F8E 30092053 20  common.30092053        User
0018EF84 300A5E55 30098F8E 34  common.30098F8E        User
0018EFB8 300A6765 300A5E55 45C common.300A5E55        User
0018F414 300A70FA 300A6765 1C  common.300A6765        User
0018F430 300A5195 300A70FA 18  common.300A70FA        User
0018F448 0509A357 300A5195 48  common.300A5195        User 
0018F490 0509D2F5 0509A357 94  preloginlogic.0509A357 User
0018F524 050D2856 0509D2F5 4C  preloginlogic.0509D2F5 User
0018F570 050C974E 050D2856 58  preloginlogic.050D2856 User
0018F5C8 050CA602 050C974E 24  preloginlogic.050C974E User
0018F5EC 050B2CFF 050CA602 C   preloginlogic.050CA602 User
0018F5F8 300C882B 050B2CFF 14  preloginlogic.050B2CFF User
0018F60C 300C8D5F 300C882B 80  common.300C882B        User
0018F68C 300C7D2A 300C8D5F 18  common.300C8D5F        User
0018F6A4 751F62FA 300C7D2A 2C  common.300C7D2A        System
0018F6D0 751F6D3A 751F62FA 78  user32.751F62FA        System
0018F748 751F77C4 751F6D3A 60  user32.751F6D3A        System
0018F7A8 751F788A 751F77C4 10  user32.751F77C4        System
0018F7B8 69F0652A 751F788A 3C  user32.751F788A        User
0018F7F4 69F06059 69F0652A 1C  hummerengine.69F0652A  User
0018F810 69F04529 69F06059 3C  hummerengine.69F06059  User
0018F84C 69F0AF44 69F04529 510 hummerengine.69F04529  User
0018FD5C 69F0B146 69F0AF44 4C  hummerengine.69F0AF44  User
0018FDA8 004014D9 69F0B146 144 hummerengine.69F0B146  User
0018FEEC 0040128B 004014D9 C   qq.004014D9            User
0018FEF8 00401A8F 0040128B 94  qq.0040128B            User
0018FF8C 76F133AA 00401A8F C   qq.00401A8F            System
0018FF98 77669F72 76F133AA 40  kernel32.76F133AA      System
0018FFD8 77669F45 77669F72 18  ntdll.77669F72         System
0018FFF0 00000000 77669F45     ntdll.77669F45         User

===============================================================================================================================================================================================
//300920DF
int __thiscall sub_300920C1(int this, char *buf, int len, struct sockaddr *to, int tolen, int flags)
{
  return sendto(*(_DWORD *)(this + 0xCC), buf, len, flags, to, tolen);
}

===============================================================================================================================================================================================

//30092053
int __thiscall sub_30091FD6(void *this, int a2, int a3, unsigned __int16 Short, wchar_t *a5, int a6)
{
  const char *v6; // eax@1
  int v7; // esi@3
  void *v9; // [sp+Ch] [bp-2Ch]@1
  int v10; // [sp+10h] [bp-28h]@0
  char v11; // [sp+14h] [bp-24h]@1
  __int16 v12; // [sp+18h] [bp-20h]@1
  unsigned __int16 v13; // [sp+1Ah] [bp-1Eh]@3
  unsigned __int32 v14; // [sp+1Ch] [bp-1Ch]@2
  unsigned int v15; // [sp+34h] [bp-4h]@1

  v9 = this;
  memset(&v12, 0, 0x10u);
  LOBYTE(v10) = 0;
  CTXStringA::CTXStringA(v10, a5, 0xFFFFFFFF);
  v15 = 0;
  v6 = (const char *)Big::getbig((Big *)&v11);
  v12 = 2;
  if ( v6 )
  {
    v14 = inet_addr(v6);
    if ( v14 == 0xFFFFFFFF )
    {
      v7 = 0xFFFFFFFF;
      goto LABEL_6;
    }
  }
  else
  {
    v14 = byteswap_ulong(0xFFFFFFFF);
  }
  v13 = byteswap_ushort(Short);
  v7 = (*(int (__stdcall **)(int, int, __int16 *, signed int, int))(*(_DWORD *)v9 + 0x38))(a2, a3, &v12, 0x10, a6);
LABEL_6:
  v15 = 0xFFFFFFFF;
  CTXStringA::~CTXStringA((CTXStringA *)&v11);
  return v7;
}
===============================================================================================================================================================================================
//30098F8E
unsigned int __stdcall sub_30098F61(int a1, wchar_t *a2, __int16 a3, int a4, int a5, int a6)
{
  unsigned int result; // eax@2
  int v7; // ecx@3

  if ( a6 )
  {
    v7 = *(_DWORD *)(a1 + 0x4C);
    *(_DWORD *)a6 = sub_30091FD6(a5, a4, a3, a2, 0);
    result = 0;
  }
  else
  {
    result = 0x80070057;
  }
  return result;
}

===============================================================================================================================================================================================
//300A5E55
void __thiscall CTXUDPDataSender::InternalSendData(CTXUDPDataSender *this, struct tagTXUDPPacket *a2)
{
  CTXUDPDataSender *v2; // ebx@1
  struct tagTXUDPPacket *v3; // edi@2
  _DWORD *v4; // eax@5
  _DWORD *v5; // ST24_4@5
  void (__stdcall **v6)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // esi@5
  int v7; // ST10_4@5
  int v8; // ST0C_4@5
  int v9; // ST08_4@5
  int v10; // eax@5
  int v11; // [sp+Ch] [bp-4h]@5
  struct tagTXUDPPacket *v12; // [sp+18h] [bp+8h]@4

  v2 = this;
  if ( *((_DWORD *)this + 1) )
  {
    v3 = a2;
    if ( !*((_WORD *)a2 + 0xC) )
    {
      CTXBSTR::operator=((struct tagTXUDPPacket *)((char *)a2 + 0x14), (CTXUDPDataSender *)((char *)this + 8));
      *((_WORD *)a2 + 0xC) = *((_WORD *)v2 + 6);
    }
    v12 = 0;
    if ( *((_BYTE *)v3 + 4) )
    {
      do
      {
        v4 = (_DWORD *)*((_DWORD *)v2 + 1);
        v11 = 0;
        v5 = v4;
        v6 = (void (__stdcall **)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(*v4 + 0x14);
        v7 = sub_300031C8(v3);
        v8 = sub_300031E7(v3);
        v9 = *((_WORD *)v2 + 6);
        v10 = CTXBSTR::operator wchar_t *((char *)v3 + 0x14);
        (*v6)(v5, v10, v9, v8, v7, &v11);
        v12 = (struct tagTXUDPPacket *)((char *)v12 + 1);
      }
      while ( (signed int)v12 < *((_BYTE *)v3 + 4) );
    }
  }
}

===============================================================================================================================================================================================
//300A6765
void __thiscall CTXUDPDataSender::DealData(CTXUDPDataSender *this, struct ITXTimerCallback *a2, struct tagTXUDPPacket *a3)
{
  struct tagTXUDPPacket *v3; // ebx@1
  CTXUDPDataSender *v4; // edi@1
  char *v5; // esi@1
  int v6; // eax@2
  int *v7; // ebx@4
  int v8; // eax@4
  int v9; // esi@4
  int v10; // eax@4
  int *v11; // ebx@4
  int v12; // esi@4
  DWORD v13; // ST08_4@4
  int v14; // eax@4
  int *v15; // ebx@4
  int v16; // eax@4
  int v17; // esi@4
  struct ITXTimerCallback *v18; // ST08_4@4
  int v19; // eax@4
  const wchar_t *v20; // edx@4
  int v21; // ecx@4
  __int16 v22; // ax@4
  _DWORD *v23; // eax@8
  int v24; // eax@13
  char v25; // al@15
  struct ITXData **v26; // [sp+4h] [bp-450h]@0
  int v27; // [sp+14h] [bp-440h]@7
  int v28; // [sp+18h] [bp-43Ch]@7
  int v29; // [sp+1Ch] [bp-438h]@9
  CTXUDPDataSender *v30; // [sp+24h] [bp-430h]@1
  struct tagTXUDPPacket *v31; // [sp+28h] [bp-42Ch]@1
  int v32; // [sp+2Ch] [bp-428h]@1
  void *v33; // [sp+30h] [bp-424h]@4
  int *v34; // [sp+34h] [bp-420h]@4
  int v35; // [sp+38h] [bp-41Ch]@1
  void *v36; // [sp+3Ch] [bp-418h]@2
  unsigned __int8 v37; // [sp+43h] [bp-411h]@14
  __int16 v38[518]; // [sp+44h] [bp-410h]@6
  unsigned int v39; // [sp+450h] [bp-4h]@4

  v3 = a3;
  v4 = this;
  v5 = (char *)this + 0x18;
  v30 = this;
  v31 = a3;
  sub_300039FA(&v35, &a2);
  sub_300A3A68(*((_DWORD *)v5 + 1), v5);
  if ( !(unsigned __int8)sub_3007DFEB(&v32) )
  {
    TXTimer::EraseTimerCallback(*((TXTimer **)v4 + 0x14), a2, (unsigned int)v26);
    v6 = sub_30022AC2(&v35);
    sub_300A6090(v6 + 4);
    sub_30090589((int)&v35, v35, v36);
  }
  *(_DWORD *)sub_300DEB04(&a2) = v3;
  if ( *((_DWORD *)v4 + 4) )
  {
    v25 = *((_BYTE *)v3 + 0x10);
    if ( v25 != 0xFEu )
      *((_BYTE *)v3 + 0x10) = v25 + 1;
  }
  else
  {
    v34 = 0;
    v39 = 0;
    Util::Data::CreateTXData((Util::Data *)&v34, v26);
    v7 = v34;
    v8 = Concurrency::cancellation_token::_FromImpl(&v33, L"dwOptType");
    v9 = *v7;
    LOBYTE(v39) = 1;
    v10 = CTXBSTR::operator wchar_t *(v8);
    (*(void (__stdcall **)(int *, int, signed int))(v9 + 0xE0))(v7, v10, 1);
    LOBYTE(v39) = 0;
    CTXBSTR::~CTXBSTR((CTXBSTR *)&v33);
    v11 = v34;
    v33 = (void *)Concurrency::cancellation_token::_FromImpl(&v36, L"dwTimeStamp");
    v12 = *v11;
    LOBYTE(v39) = 2;
    v13 = GetTickCount();
    v14 = CTXBSTR::operator wchar_t *(v33);
    (*(void (__stdcall **)(int *, int, DWORD))(v12 + 0xE0))(v11, v14, v13);
    LOBYTE(v39) = 0;
    CTXBSTR::~CTXBSTR((CTXBSTR *)&v36);
    v15 = v34;
    v16 = Concurrency::cancellation_token::_FromImpl(&v36, L"dwCookie");
    v17 = *v15;
    v18 = a2;
    LOBYTE(v39) = 3;
    v19 = CTXBSTR::operator wchar_t *(v16);
    (*(void (__stdcall **)(int *, int, struct ITXTimerCallback *))(v17 + 0xE0))(v15, v19, v18);
    LOBYTE(v39) = 0;
    CTXBSTR::~CTXBSTR((CTXBSTR *)&v36);
    v20 = L"OnSendCmd(pData)";
    v21 = 0;
    v22 = 0x4F;
    do
    {
      if ( v22 == 0x28 )
        break;
      v38[v21++] = v22;
      ++v20;
      v22 = *v20;
    }
    while ( *v20 );
    v38[v21] = 0;
    sub_300A4225(&v27, 0, v38);
    LOBYTE(v39) = 4;
    sub_3005549E(v28, &v27);
    v35 = v32;
    v36 = v33;
    while ( 1 )
    {
      sub_3005549E(v29, &v27);
      if ( (unsigned __int8)sub_3007DFEB(&v32) )
        break;
      v23 = (_DWORD *)sub_300AF4FF(&v35);
      (*(void (__stdcall **)(_DWORD, int))(*(_DWORD *)*v23 + 0xC))(*v23, (int)v34);
      sub_30022A47(&v35);
    }
    LOBYTE(v39) = 0;
    sub_300C25D3((int)&v27);  
    CTXUDPDataSender::InternalSendData(v30, v31); //300A6765
    v39 = 0xFFFFFFFF;
    if ( v34 )
      (*(void (__stdcall **)(int))(*v34 + 8))((int)v34);
    v3 = v31;
    v4 = v30;
  }
  v24 = *((_DWORD *)v3 + 2);
  if ( v24 )
  {
    v37 = 0;
    (*(void (__stdcall **)(int, _DWORD, char *))(*(_DWORD *)v24 + 0x20))(v24, 0, (char *)&v37);
    TXTimer::SetTimeout((TXTimer *)(0x3E8 * v37), *((_DWORD *)v4 + 0x14), a2, (unsigned int)v26); 
  }
  else
  {
    TXTimer::SetInterval(*((TXTimer **)v3 + 3), *((_DWORD *)v4 + 0x14), a2, (unsigned int)v26);
  }
}

===============================================================================================================================================================================================
//300A70FA
int __thiscall CTXUDPDataSender::SendData(CTXUDPDataSender *this, struct ITXData *a2, int a3, unsigned __int8 *a4, unsigned __int32 *a5)
{
  int v5; // edi@1
  CTXUDPDataSender *v6; // esi@1
  void *v7; // eax@5
  int result; // eax@12
  unsigned int v9; // [sp+0h] [bp-Ch]@0

  v5 = 0;
  v6 = this;
  if ( a3 > 0 && a4 && a5 && CTXUDPDataSender::IsReadyToSendData(this) )
  {
    v7 = operator new(0x1Cu);
    if ( v7 )
      v5 = sub_300A5EA5(v7);
    sub_300063AF((Util::Data *)v5, (int)a4, a3);
    CTXBSTR::operator=((CTXStringW *)(v5 + 0x14), (CTXUDPDataSender *)((char *)v6 + 8));
    *(_WORD *)(v5 + 0x18) = *((_WORD *)v6 + 6);
    CTXUDPDataSender::ApplySettings(v6, a2, (struct tagTXUDPPacket *)v5);
    if ( !*a5 )
      *a5 = CTXUDPDataSender::GetNextCookie();
    if ( GetCurrentThreadId() == CTXUDPDataSender::m_dwUIThread )
    {
      CTXUDPDataSender::DealData(v6, (struct ITXTimerCallback *)*a5, (struct tagTXUDPPacket *)v5);
    }
    else
    {
      EnterCriticalSection((LPCRITICAL_SECTION)((char *)v6 + 0x34));
      *(_DWORD *)sub_300DEB04(a5) = v5;
      LeaveCriticalSection((LPCRITICAL_SECTION)((char *)v6 + 0x34));
      TXTimer::SetAsyncCallback(*((TXTimer **)v6 + 0x16), (struct ITXAsyncCallback *)*a5, v9);
    }
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

===============================================================================================================================================================================================
//300A5195  消息通用方法
unsigned int __stdcall sub_300A5136(int a1, int a2, unsigned __int8 *a3, unsigned __int32 *a4, struct ITXData *a5)
{
  unsigned int result; // eax@2

  if ( *(_DWORD *)(a1 + 0x30) )
  {
    if ( a2 > 0 && a3 && a4 )
    {
      CTXUDPDataSender::SendData((CTXUDPDataSender *)(a1 + 0x34), a5, a2, a3, a4);
      result = 0;
    }
    else
    {
      sub_300A772D(
        L"file",
        0xFC,
        L"func",
        3,
        L"UDPChannel",
        (const char *)L"nBufSize[%d] pcBuf[%lu] pdwCookie[%lu]",
        a2,
        a3,
        a4);
      result = 0x80070057;
    }
  }
  else
  {
    sub_300A772D(L"file", 0xF5, L"func", 3, L"UDPChannel", (const char *)L"%s", (unsigned int)L"NULL == m_pUDP");
    result = 0x80004004;
  }
  return result;
}

===============================================================================================================================================================================================



===============================================================================================================================================================================================

===============================================================================================================================================================================================



===============================================================================================================================================================================================

===============================================================================================================================================================================================



===============================================================================================================================================================================================

===============================================================================================================================================================================================



===============================================================================================================================================================================================

===============================================================================================================================================================================================



===============================================================================================================================================================================================

===============================================================================================================================================================================================



===============================================================================================================================================================================================

===============================================================================================================================================================================================



===============================================================================================================================================================================================

===============================================================================================================================================================================================



===============================================================================================================================================================================================

===============================================================================================================================================================================================



===============================================================================================================================================================================================

===============================================================================================================================================================================================



===============================================================================================================================================================================================

===============================================================================================================================================================================================



===============================================================================================================================================================================================

===============================================================================================================================================================================================



===============================================================================================================================================================================================

===============================================================================================================================================================================================



===============================================================================================================================================================================================

===============================================================================================================================================================================================



===============================================================================================================================================================================================

===============================================================================================================================================================================================


